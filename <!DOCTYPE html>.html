<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë½ëœ¨ì™€ í•¨ê»˜í•˜ëŠ” ì‹œì• í‹€ í…ŒíŠ¸ë¦¬ìŠ¤</title>
    <style>
        body {
            /* ë°°ê²½ ì´ë¯¸ì§€ ì„¤ì • (íŒŒì¼ëª…ì„ background.pngë¡œ ë§ì¶°ì£¼ì„¸ìš”) */
            background-image: url('background.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-color: #0f1428; /* ì´ë¯¸ì§€ ì—†ì„ ë•Œ ê¸°ë³¸ ìƒ‰ìƒ */
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Arial', sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: manipulation;
        }
        h1 { text-shadow: 2px 2px 4px rgba(0,0,0,0.7); }
        .game-container { position: relative; margin-top: 20px; display: flex; gap: 20px; }
        canvas { border: 4px solid #ffffff33; border-radius: 8px; background: rgba(0,0,0,0.6); }
        .info { 
            text-align: left; min-width: 120px; 
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px;
        }
        .score-effect {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; font-weight: bold; color: #ffff00; text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            pointer-events: none; z-index: 10; opacity: 0; transition: opacity 0.3s;
        }
        .hidden { display: none; }
        .controls { display: grid; grid-template-columns: repeat(3, 80px); gap: 10px; margin-top: 20px; }
        .btn {
            width: 80px; height: 80px; background: rgba(68, 68, 68, 0.8); border-radius: 15px;
            display: flex; justify-content: center; align-items: center; font-size: 24px;
            user-select: none; cursor: pointer; border: 1px solid #ffffff55;
        }
        .btn:active { background: #666; }
        #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; text-align: center; z-index: 20;
        }
    </style>
</head>
<body>
    <h1>ğŸ® ë½ëœ¨ì˜ ì‹œì• í‹€ í…ŒíŠ¸ë¦¬ìŠ¤</h1>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        <div id="scoreEffect" class="score-effect"></div>
        
        <div class="info">
            <p>ë‹¤ìŒ ë¸”ë¡:</p>
            <canvas id="nextCanvas" width="100" height="100"></canvas>
            <hr>
            <p>ì ìˆ˜: <span id="score">0</span></p>
            <p>ë ˆë²¨: <span id="level">1</span></p>
            <p>ì¤„ìˆ˜: <span id="lines">0</span></p>
        </div>

        <div id="gameOver" class="hidden">
            <h2>ê²Œì„ ë!</h2>
            <p>ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span></p>
            <button onclick="startGame()" style="padding:10px 20px; font-size:18px; cursor:pointer; border-radius:10px;">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <div class="controls">
        <div></div><div class="btn" id="rotateBtn">ğŸ”„</div><div></div>
        <div class="btn" id="leftBtn">â—€ï¸</div><div class="btn" id="downBtn">â–¼</div><div class="btn" id="rightBtn">â–¶ï¸</div>
    </div>

    <audio id="bgm" src="bgm.mp3" loop></audio>

    <script>
        const COLS = 10; const ROWS = 20; const BLOCK_SIZE = 30;
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');

        let board = []; let currentPiece = null; let nextPiece = null;
        let score = 0; let level = 1; let lines = 0;
        let dropCounter = 0; let dropInterval = 1000; let lastTime = 0;
        let gameRunning = false;

        // ì´ëª¨ì§€ ë°±ì—… ì„¤ì •
        const FACE_EMOJIS = { I:'ğŸ˜Š', O:'ğŸ˜ƒ', T:'ğŸ˜„', S:'ğŸ˜', Z:'ğŸ˜†', J:'ğŸ˜‹', L:'ğŸ˜' };
        const COLORS = { I:'#00f0f0', O:'#f0f000', T:'#a000f0', S:'#00f000', Z:'#f00000', J:'#0000f0', L:'#f0a000' };
        
        const PIECES = {
            I: [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]],
            O: [[[1,1],[1,1]]],
            T: [[[0,1,0],[1,1,1],[0,0,0]], [[0,1,0],[0,1,1],[0,1,0]], [[0,0,0],[1,1,1],[0,1,0]], [[0,1,0],[1,1,0],[0,1,0]]],
            S: [[[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[0,1,1],[0,0,1]]],
            Z: [[[1,1,0],[0,1,1],[0,0,0]], [[0,0,1],[0,1,1],[0,1,0]]],
            J: [[[1,0,0],[1,1,1],[0,0,0]], [[0,1,1],[0,1,0],[0,1,0]], [[0,0,0],[1,1,1],[0,0,1]], [[0,1,0],[0,1,0],[1,1,0]]],
            L: [[[0,0,1],[1,1,1],[0,0,0]], [[0,1,0],[0,1,0],[0,1,1]], [[0,0,0],[1,1,1],[1,0,0]], [[1,1,0],[0,1,0],[0,1,0]]]
        };

        // ì´ë¯¸ì§€ ë¡œë“œ
        const blockImages = {};
        'IOTSZJL'.split('').forEach(type => {
            blockImages[type] = new Image();
            if(type === 'I') blockImages[type].src = 'block-face.png';
            else if(type === 'T') blockImages[type].src = 'block-face01.png';
            else if(type === 'O') blockImages[type].src = 'block-face02.png';
            else if(type === 'S') blockImages[type].src = 'block-face03.png';
            else blockImages[type].src = `block-${type}.png`;
        });

        function createBoard() { board = Array.from({length: ROWS}, () => Array(COLS).fill(0)); }

        function createPiece() {
            const types = 'IOTSZJL';
            const type = types[Math.floor(Math.random() * types.length)];
            return { matrix: PIECES[type][0], type, x: 3, y: 0, rotation: 0 };
        }

        function drawBlock(c, x, y, type, size, isNext = false) {
            const img = blockImages[type];
            if (img.complete && img.width > 0) {
                c.drawImage(img, x * size, y * size, size, size);
            } else {
                c.fillStyle = COLORS[type];
                c.fillRect(x * size, y * size, size, size);
                c.strokeStyle = 'white'; c.strokeRect(x * size, y * size, size, size);
                c.fillStyle = 'white'; c.font = `${size*0.7}px Arial`;
                c.textAlign = 'center'; c.textBaseline = 'middle';
                c.fillText(FACE_EMOJIS[type], x * size + size/2, y * size + size/2);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            board.forEach((row, y) => row.forEach((value, x) => { if(value) drawBlock(ctx, x, y, value, BLOCK_SIZE); }));
            currentPiece.matrix.forEach((row, y) => row.forEach((value, x) => {
                if(value) drawBlock(ctx, currentPiece.x + x, currentPiece.y + y, currentPiece.type, BLOCK_SIZE);
            }));
        }

        function drawNext() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            nextPiece.matrix.forEach((row, y) => row.forEach((value, x) => {
                if(value) drawBlock(nextCtx, x + 0.5, y + 0.5, nextPiece.type, 25);
            }));
        }

        function collide(p, ox, oy) {
            return p.matrix.some((row, y) => row.some((value, x) => {
                let nx = p.x + x + ox, ny = p.y + y + oy;
                return value && (nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0 && board[ny][nx]));
            }));
        }

        function drop() {
            if (!collide(currentPiece, 0, 1)) { currentPiece.y++; } 
            else {
                merge(); clearLines();
                currentPiece = nextPiece; nextPiece = createPiece();
                if (collide(currentPiece, 0, 0)) {
                    gameRunning = false;
                    document.getElementById('gameOver').classList.remove('hidden');
                    document.getElementById('finalScore').textContent = score;
                }
                drawNext();
            }
            dropCounter = 0;
        }

        function merge() {
            currentPiece.matrix.forEach((row, y) => row.forEach((value, x) => {
                if(value) board[currentPiece.y + y][currentPiece.x + x] = currentPiece.type;
            }));
        }

        function clearLines() {
            let count = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(v => v !== 0)) {
                    board.splice(y, 1); board.unshift(Array(COLS).fill(0));
                    count++; y++;
                }
            }
            if (count > 0) {
                score += count * 100 * level; lines += count;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level-1)*100);
                updateUI(); showEffect(`+${count*100}ì !`);
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;
        }

        function showEffect(txt) {
            const el = document.getElementById('scoreEffect');
            el.textContent = txt; el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 800);
        }

        function rotate(p) {
            const prev = p.matrix;
            p.rotation = (p.rotation + 1) % PIECES[p.type].length;
            p.matrix = PIECES[p.type][p.rotation];
            if (collide(p, 0, 0)) { p.matrix = prev; }
        }

        function update(time = 0) {
            const dt = time - lastTime; lastTime = time;
            dropCounter += dt;
            if (dropCounter > dropInterval) drop();
            draw();
            if (gameRunning) requestAnimationFrame(update);
        }

        function startGame() {
            createBoard(); score = 0; level = 1; lines = 0; dropInterval = 1000;
            currentPiece = createPiece(); nextPiece = createPiece();
            gameRunning = true; updateUI(); drawNext();
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('bgm').play().catch(() => {});
            lastTime = 0; requestAnimationFrame(update);
        }

        // ì œì–´
        document.addEventListener('keydown', e => {
            if (!gameRunning) return;
            if (e.key === 'ArrowLeft' && !collide(currentPiece, -1, 0)) currentPiece.x--;
            if (e.key === 'ArrowRight' && !collide(currentPiece, 1, 0)) currentPiece.x++;
            if (e.key === 'ArrowDown') drop();
            if (e.key === 'ArrowUp') rotate(currentPiece);
        });

        document.getElementById('leftBtn').onclick = () => { if(gameRunning && !collide(currentPiece, -1, 0)) currentPiece.x--; };
        document.getElementById('rightBtn').onclick = () => { if(gameRunning && !collide(currentPiece, 1, 0)) currentPiece.x++; };
        document.getElementById('downBtn').onclick = () => { if(gameRunning) drop(); };
        document.getElementById('rotateBtn').onclick = () => { if(gameRunning) rotate(currentPiece); };

        window.onload = startGame;
    </script>
</body>
</html>